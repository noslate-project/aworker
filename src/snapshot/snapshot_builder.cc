#include "snapshot_builder.h"
#include <iostream>
#include <sstream>
#include <string>
#include <type_traits>
#include "aworker.h"
#include "aworker_version.h"
#include "base_object-inl.h"
#include "debug_utils.h"
#include "error_handling.h"
#include "external_references.h"
#include "native_module_manager.h"
#include "snapshot/snapshotable.h"
#include "v8.h"

namespace aworker {

using v8::Context;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::SnapshotCreator;
using v8::StartupData;

void DeserializeContext::EnqueueDeserializeRequest(
    DeserializeRequestCallback cb,
    v8::Local<v8::Object> holder,
    int index,
    const EmbedderFieldStartupData* info) {
  DeserializeRequest request{cb, {isolate(), holder}, index, info};
  deserialize_requests_.push_back(std::move(request));
}

void DeserializeContext::RunDeserializeRequests() {
  HandleScope scope(isolate());
  Local<Context> ctx = immortal_->context();
  Isolate* is = isolate();
  while (!deserialize_requests_.empty()) {
    DeserializeRequest request(std::move(deserialize_requests_.front()));
    deserialize_requests_.pop_front();
    Local<Object> holder = request.holder.Get(is);
    request.cb(ctx, holder, request.index, request.info);
    request.holder.Reset();
  }
}

template <typename T>
void WriteVector(std::stringstream* ss, const T* vec, size_t size) {
  for (size_t i = 0; i < size; i++) {
    *ss << std::to_string(vec[i]) << (i == size - 1 ? '\n' : ',');
  }
}

std::string GetDefName(const std::string& id) {
  char buf[64] = {0};
  size_t size = id.size();
  CHECK_LT(size, sizeof(buf));
  for (size_t i = 0; i < size; ++i) {
    char ch = id[i];
    buf[i] = (ch == '-' || ch == '/' || ch == '.') ? '_' : ch;
  }
  return buf;
}

std::string FormatSize(size_t size) {
  char buf[64] = {0};
  if (size < 1024) {
    snprintf(buf, sizeof(buf), "%.2fB", static_cast<double>(size));
  } else if (size < 1024 * 1024) {
    snprintf(buf, sizeof(buf), "%.2fKB", static_cast<double>(size / 1024));
  } else {
    snprintf(
        buf, sizeof(buf), "%.2fMB", static_cast<double>(size / 1024 / 1024));
  }
  return buf;
}

void WriteCachedDataDefinition(std::stringstream* ss,
                               const std::string& id,
                               const uint8_t* data,
                               size_t size) {
  *ss << "static const uint8_t " << GetDefName(id) << "[] = {\n";
  WriteVector(ss, data, size);
  *ss << "};";
}

void WriteCachedDataInitializer(std::stringstream* ss, const std::string& id) {
  std::string def_name = GetDefName(id);
  *ss << "    { \"" << id << "\",\n";
  *ss << "      {" << def_name << ",\n";
  *ss << "       " << def_name << " + arraysize(" << def_name << "),\n";
  *ss << "      }\n";
  *ss << "    },\n";
}

std::string SnapshotData::ToSource() {
  std::stringstream ss;

  ss << R"(#include <cstddef>
#include "snapshot/embedded_snapshot_data.h"
#include "v8.h"

// This file is generated by tools/snapshot. Do not edit.

namespace aworker {

static const char blob_data[] = {
)";
  WriteVector(&ss, blob.data, blob.raw_size);
  ss << R"(};

static const int blob_size = )"
     << blob.raw_size << R"(;
static v8::StartupData blob = { blob_data, blob_size };
)";

  ss << R"(v8::StartupData* EmbeddedSnapshotData::GetSnapshotBlob() {
  return &blob;
}

static const std::vector<size_t> isolate_data_indexes {
)";
  WriteVector(&ss, isolate_data_indexes.data(), isolate_data_indexes.size());
  ss << R"(};

const std::vector<size_t>* EmbeddedSnapshotData::GetIsolateDataIndexes() {
  return &isolate_data_indexes;
}

static const std::vector<size_t> immortal_data_indexes {
)";
  WriteVector(&ss, immortal_data_indexes.data(), immortal_data_indexes.size());
  ss << R"(};

const std::vector<size_t>* EmbeddedSnapshotData::GetImmortalDataIndexes() {
  return &immortal_data_indexes;
}

)";

  size_t total = 0;
  for (const auto& it : native_module_caches) {
    total += it.data.size();
    WriteCachedDataDefinition(&ss, it.id, it.data.data(), it.data.size());
    ss << "\n\n";
    std::string size_str = FormatSize(it.data.size());
    std::string total_str = FormatSize(total);
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       "Generated cache for %s, size = %s, total = %s\n",
                       it.id.c_str(),
                       size_str.c_str(),
                       total_str.c_str());
  }

  ss << R"(
static const std::vector<NativeModuleCache> native_module_caches {
)";
  for (const auto& it : native_module_caches) {
    WriteCachedDataInitializer(&ss, it.id);
  }
  ss << R"(};

const std::vector<NativeModuleCache>* EmbeddedSnapshotData::GetNativeModuleCaches() {
  return &native_module_caches;
}

}  // namespace aworker
)";

  return ss.str();
}

namespace {
template <typename T, typename = std::enable_if_t<std::is_scalar<T>::value>>
inline void Write(std::ofstream& out, T value) {
  out.write(reinterpret_cast<const char*>(&value), sizeof(T));
}

template <typename T, typename = std::enable_if_t<std::is_scalar<T>::value>>
inline void Read(std::ifstream& input, T* value) {
  input.read(reinterpret_cast<char*>(value), sizeof(T));
}
}  // namespace

// The data header consists of uint32_t-sized entries:
// [0] magic number
// [1] version hash
// [3] startup blob size
// [4] isolate_data_indexes_size
// [5] immortal_data_indexes_size
void SnapshotData::WriteToFile(const std::string& filename) {
  std::ofstream out(filename, std::ios::out | std::ios::binary);
  CHECK(out.is_open());
  per_process::Debug(
      DebugCategory::MKSNAPSHOT,
      "version_hash(%zu) blob_size(%d) isolate_data_indexes_size(%d) "
      "immortal_data_indexes_size(%d)\n",
      Version::hash(),
      blob.raw_size,
      isolate_data_indexes.size(),
      immortal_data_indexes.size());
  Write(out, kMagic);
  Write(out, Version::hash());
  Write(out, static_cast<uint32_t>(blob.raw_size));
  Write(out, static_cast<uint32_t>(isolate_data_indexes.size()));
  Write(out, static_cast<uint32_t>(immortal_data_indexes.size()));
  Write(out, static_cast<uint32_t>(native_module_caches.size()));

  out.write(blob.data, blob.raw_size);
  out.write(reinterpret_cast<const char*>(isolate_data_indexes.data()),
            isolate_data_indexes.size() * sizeof(size_t));
  out.write(reinterpret_cast<const char*>(immortal_data_indexes.data()),
            immortal_data_indexes.size() * sizeof(size_t));
  for (uint32_t idx = 0; idx < native_module_caches.size(); idx++) {
    auto const& it = native_module_caches[idx];
    Write(out, static_cast<uint32_t>(it.id.size()));
    Write(out, static_cast<uint32_t>(it.data.size()));
    out.write(reinterpret_cast<const char*>(it.id.c_str()),
              it.id.size() * sizeof(char));
    out.write(reinterpret_cast<const char*>(it.data.data()),
              it.data.size() * sizeof(uint8_t));
  }
}

// static
std::unique_ptr<SnapshotData> SnapshotData::ReadFromFile(
    const std::string& filename) {
  std::ifstream input(filename, std::ios::in | std::ios::binary);
  if (!input.is_open()) {
    fprintf(stderr,
            "Failed to open external snapshot file: %s\n",
            filename.c_str());
    return nullptr;
  }
  uint32_t magic;
  uint64_t version_hash;
  uint32_t blob_size;
  uint32_t isolate_data_indexes_size;
  uint32_t immortal_data_indexes_size;
  uint32_t native_module_caches_size;

  Read(input, &magic);
  Read(input, &version_hash);
  Read(input, &blob_size);
  Read(input, &isolate_data_indexes_size);
  Read(input, &immortal_data_indexes_size);
  Read(input, &native_module_caches_size);
  per_process::Debug(
      DebugCategory::MKSNAPSHOT,
      "magic(%d) version_hash(%zu) blob_size(%d) isolate_data_indexes_size(%d) "
      "immortal_data_indexes_size(%d) native_module_caches_size(%d)\n",
      magic,
      version_hash,
      blob_size,
      isolate_data_indexes_size,
      immortal_data_indexes_size,
      native_module_caches_size);
  if (magic != SnapshotData::kMagic) {
    fprintf(stderr,
            "External startup snapshot file magic not match: %s\n",
            filename.c_str());
    return nullptr;
  }
  if (version_hash != Version::hash()) {
    fprintf(stderr,
            "External startup snapshot file version hash not match: %s\n",
            filename.c_str());
    return nullptr;
  }

  std::unique_ptr<SnapshotData> data = std::make_unique<SnapshotData>();
  char* blob_data = new char[blob_size];
  data->blob.data = blob_data;
  data->blob.raw_size = blob_size;
  data->isolate_data_indexes = std::vector<size_t>(isolate_data_indexes_size);
  data->immortal_data_indexes = std::vector<size_t>(immortal_data_indexes_size);
  data->native_module_caches =
      std::vector<NativeModuleCache>(native_module_caches_size);

  input.read(blob_data, blob_size);
  input.read(reinterpret_cast<char*>(data->isolate_data_indexes.data()),
             isolate_data_indexes_size * sizeof(size_t));
  input.read(reinterpret_cast<char*>(data->immortal_data_indexes.data()),
             immortal_data_indexes_size * sizeof(size_t));
  for (uint32_t idx = 0; idx < native_module_caches_size; idx++) {
    auto& it = data->native_module_caches[idx];
    uint32_t id_size;
    uint32_t data_size;
    Read(input, &id_size);
    Read(input, &data_size);
    it.id = std::string(id_size, '\0');
    it.data = std::vector<uint8_t>(data_size);
    input.read(const_cast<char*>(it.id.data()), id_size * sizeof(char));
    input.read(reinterpret_cast<char*>(it.data.data()),
               data_size * sizeof(uint8_t));
    per_process::Debug(DebugCategory::MKSNAPSHOT,
                       "Read native module cache(%s, size: %d)\n",
                       it.id.c_str(),
                       data_size);
  }

  return data;
}

void ResetIsolateHandlers(v8::Isolate* isolate) {
  isolate->RemoveMessageListeners(errors::OnMessage);
}

void SnapshotBuilder::Generate(SnapshotData* out,
                               AworkerPlatform* platform,
                               AworkerMainInstance* main_instance) {
  // Transfer ownership to SnapshotCreator later...
  Isolate* isolate = main_instance->ReleaseIsolate();

  isolate->SetCaptureStackTraceForUncaughtExceptions(
      true, 10, v8::StackTrace::StackTraceOptions::kDetailed);
  SnapshotCreator creator(
      isolate,
      per_process::external_reference_registry.external_references().data());

  {
    main_instance->Initialize(IsolateCreationMode::kCreateSnapshot);
    Immortal* immortal = main_instance->immortal();
    IsolateData* isolate_data = main_instance->isolate_data();

    std::vector<size_t> isolate_data_indexes;
    std::vector<size_t> immortal_data_indexes;
    {
      HandleScope scope(isolate);
      creator.SetDefaultContext(Context::New(isolate));

      Local<Context> context = immortal->context();
      Context::Scope context_scope(context);

      bool compilation_succeeded =
          NativeModuleManager::Instance().CompileAll(context);
      CHECK(compilation_succeeded);
      /**
       * Bootstrap builtin modules.
       */
      immortal->Bootstrap();
      CHECK_EQ(immortal->tracked_handle_wraps.size(), 0);
      CHECK_EQ(immortal->tracked_base_objects.size(), 0);
      std::string filename = immortal->commandline_parser()->script_filename();
      if (!filename.empty()) {
        immortal->BootstrapPerExecution();
        immortal->BootstrapAgent(filename);
        CHECK(immortal->StartExecution().ToChecked());
        // Disallow handles been created without local HandleScopes.
        v8::SealHandleScope scope(isolate);
        uv_run(immortal->event_loop(), UV_RUN_DEFAULT);
      }

      // Cleanup handles.
      immortal->RunCleanupHooks();

      // Collect no-reference base objects.
      v8::V8::SetFlagsFromString("--expose-gc");
      isolate->RequestGarbageCollectionForTesting(
          Isolate::GarbageCollectionType::kFullGarbageCollection);
      v8::V8::SetFlagsFromString("--no-expose-gc");
      platform->task_runner()->DrainTasks();
      {
        // Disallow handles been created without local HandleScopes.
        v8::SealHandleScope scope(isolate);
        uv_run(immortal->event_loop(), UV_RUN_DEFAULT);
      }

      isolate_data_indexes = isolate_data->Serialize(&creator);
      immortal_data_indexes = immortal->Serialize(&creator);
      size_t index =
          creator.AddContext(context,
                             v8::SerializeInternalFieldsCallback(
                                 SerializeAworkerInternalFields, nullptr));
      CHECK_EQ(index, AworkerMainInstance::kMainContextIndex);
    }

    ResetIsolateHandlers(isolate);
    // Must be out of HandleScope
    StartupData blob =
        creator.CreateBlob(SnapshotCreator::FunctionCodeHandling::kKeep);
    CHECK(blob.CanBeRehashed());
    // Release Isolate-bound instances
    std::unique_ptr<Immortal> immortal_owner = main_instance->GetImmortal();
    immortal_owner->StopAgent();
    immortal_owner.reset();
    main_instance->GetIsolateData().reset();

    // transfer ownership of blob to out;
    out->blob = blob;
    out->isolate_data_indexes = isolate_data_indexes;
    out->immortal_data_indexes = immortal_data_indexes;
    out->native_module_caches =
        NativeModuleManager::Instance().GetNativeModuleCaches();
  }
}

void SnapshotBuilder::Generate(SnapshotData* out, int argc, char** argv) {
  aworker::AworkerPlatform platform;
  v8::V8::InitializePlatform(&platform);
  v8::V8::Initialize();

  {
    AworkerMainInstance main_instance(
        &platform, std::make_unique<CommandlineParserGroup>(argc, argv));
    Generate(out, &platform, &main_instance);
  }

  v8::V8::Dispose();
  v8::V8::DisposePlatform();
}
}  // namespace aworker
